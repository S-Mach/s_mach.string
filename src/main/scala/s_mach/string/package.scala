/*
                    ,i::,
               :;;;;;;;
              ;:,,::;.
            1ft1;::;1tL
              t1;::;1,
               :;::;               _____        __  ___              __
          fCLff ;:: tfLLC         / ___/      /  |/  /____ _ _____ / /_
         CLft11 :,, i1tffLi       \__ \ ____ / /|_/ // __ `// ___// __ \
         1t1i   .;;   .1tf       ___/ //___// /  / // /_/ // /__ / / / /
       CLt1i    :,:    .1tfL.   /____/     /_/  /_/ \__,_/ \___//_/ /_/
       Lft1,:;:       , 1tfL:
       ;it1i ,,,:::;;;::1tti      s_mach.string
         .t1i .,::;;; ;1tt        Copyright (c) 2014 S-Mach, Inc.
         Lft11ii;::;ii1tfL:       Author: lance.gatlin@gmail.com
          .L1 1tt1ttt,,Li
            ...1LLLL...
*/
package s_mach

import s_mach.string.impl.StringOps

import scala.util.matching.Regex
import scala.util.matching.Regex.Match

package object string {

  implicit class SMach_String_PimpMyString(val self: String) extends AnyVal {
    /** @return string with suffix appended if string does not end with suffix
      */
    @inline def ensureSuffix(suffix: String) : String =
      StringOps.ensureSuffix(self, suffix)

    /** @return string with all occurrences of regex replaced with the paired
     *         string returned by supplying the match generated by the regex.
     *         Ensures recursive replacements cannot occur.
     */
    @inline def findRegexReplaceMatch(
      zomRegex: Seq[(Regex, Match => String)]
    ) : String = StringOps.findRegexReplaceMatch(self, zomRegex)

    /** @return string with all occurrences of regex replaced with the paired
      *         string. Ensures recursive replacements cannot occur.
      *
      */
    @inline def findRegexReplace(
      zomRegex: Seq[(Regex, String)]
    ) : String = StringOps.findRegexReplace(self, zomRegex)

    /** @return string with all replacements. For each (find,replace) pair, all
      *         occurrences of find are substituted with replace. Ensures
      *         recursive replacements cannot occur.
      */
    @inline def findReplace(
      fr: Seq[(String, String)],
      caseSensitive: Boolean = true
    ) : String = StringOps.findReplace(self, caseSensitive, fr)

    /** @return string with all replacements. For each (find,replace) pair, all
      *         occurrences of find as a word are substituted with replace.
      *         Ensures recursive replacements cannot occur.
      */
    @inline def findReplaceWords(
      fr: Seq[(String, String)],
      caseSensitive: Boolean = true
    )(implicit splitter:WordSplitter) : String =
      StringOps.findReplaceWords(self, caseSensitive, fr)

    /** @return string with all replacements. For each (find*,replace) pair, all
      *         occurrences of find are substituted with replace. Ensures
      *         recursive replacements cannot occur. */
    @inline def findAllReplace(
      fr: Seq[(Seq[String], String)],
      caseSensitive: Boolean
    ) : String = StringOps.findAllReplace(self, caseSensitive, fr)

    /** @return string with all replacements. For each (find*,replace) pair, all
      *         occurrences of find as a word are substituted with replace.
      *         Ensures recursive replacements cannot occur. */
    @inline def findAllReplaceWords(
      fr: Seq[(Seq[String], String)],
      caseSensitive: Boolean = true
    )(implicit splitter:WordSplitter) : String =
      StringOps.findAllReplaceWords(self, caseSensitive, fr)

    /** @return string with all whitespace collapsed to a single space and all
      *         leading and trailing whitespace trimmed */
    @inline def collapseWhitespace : String = StringOps.collapseWhitespace(self)

    /** @return the first character to uppercase and the remaining characters to
      *         lowercase */
    @inline def toProperCase : String = StringOps.toProperCase(self)

    /** @return all whitespace collapsed, each word in proper case */
    @inline def toTitleCase(implicit words:WordSplitter) : String =
      StringOps.toTitleCase(self)

    /** @return all words camel-cased i.e. camelCase */
    @inline def toCamelCase(implicit words:WordSplitter) : String =
      StringOps.toCamelCase(self)

    /** @return all words camel-cased i.e. CamelCase */
    @inline def toPascalCase(implicit words:WordSplitter) : String =
      StringOps.toPascalCase(self)

    /** @return all words camel-cased i.e. camel_case */
    @inline def toSnakeCase(implicit  words:WordSplitter) : String =
      StringOps.toSnakeCase(self)

    /** @return string with all lines indented by n occurrences of s */
    @inline def indent(n: Int, spacer: String = " ") : String =
      StringOps.indent(self, n, spacer)

    /** @return None if string length is 0 OR Some(String) if length > 0 */
    @inline def toOption : Option[String] = StringOps.toOption(self)

    /** @return None if String fails to convert to Double OR Some(Double) if
      *         string can be converted to a valid Double value */
    @inline def toDoubleOpt : Option[Double] = StringOps.toDoubleOpt(self)

    /** @return None if String fails to convert to Long OR Some(Long) if string
      *         can be converted to a valid Long value */
    @inline def toLongOpt : Option[Long] = StringOps.toLongOpt(self)

    /** @return None if String fails to convert to Int OR Some(Int) if string
      *         can be converted to a valid Int value */
    @inline def toIntOpt : Option[Int] = StringOps.toIntOpt(self)

    /** @return None if String fails to convert to A OR Some(A) if string can be
      *         converted to a valid A value */
    @inline def convert[A](f: String => A) : Option[A] =
      StringOps.convert(self, f)

    /** @return all words contained in string */
    @inline def toWords(implicit splitter:WordSplitter) : Iterator[String] =
      StringOps.toWords(self)
  }

}